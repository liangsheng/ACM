# 题目描述

在一个 **<font color="#FF0000">圆形</font>** 操场的四周摆放 $n$ 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 $2$ 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。

试设计出一个算法,计算出将 $n$ 堆石子合并成 $1$ 堆的最小得分和最大得分。

# 输入格式

第一行，一个整数 $n$。

第二行，$n$ 个整数 $a_i$。

# 输出格式

输出文件仅一个整数，也就是最小代价。

```input1
4
4 5 9 4
```

```output1
43
54
```

# 提示
**【样例 #1 解释】**

<details>
<summary><font color="#FF0000">请思考后再点击查看提示</font></summary>

* 首先回忆下石子排成一行（不是环形）的解法
* 本题的 $n$ 不超过 $300$，所以 $O(n^3)$ 的算法可以通过
* $dp[i][j]$ 表示将 $a[i], a[i + 1] \cdots, a[j]$ 合并的最小代价
* 可以枚举最后一次合并的位置 $k$，那么有
* $dp[i][j] = min(dp[i][k] + dp[k + 1][j] + sum(a[i..j]))$
* 总共有 $n^2$ 个状态，状态转移需要 $O(n)$，所有总的时间复杂度是 $O(n^3)$

* 处理环形的一般套路是将 **<font color="#FF0000">原数组复制一份，拼接在原数组后面</font>**
* 这样最后环形的解就是 $dp[1][n], dp[2][n+1], \dots dp[n+1][2n]$ 中的最小值

</details>

# 数据规模与限制
* $1 \leq n \leq 100$
* $1 \leq a_i \leq 20$

# 来源
* [luogu_P1180_NOI1995_石子合并](https://www.luogu.com.cn/problem/P1880)