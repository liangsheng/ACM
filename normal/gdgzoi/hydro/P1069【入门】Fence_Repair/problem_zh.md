# 题目描述

农场主约翰想修理牧场周围一小段栅栏。他测量了栅栏，发现需要 $N$ 块木板（$1 \le N \le 2 \times 10^4$），每块木板的长度为某个整数单位 $L_i(1 \le L_i \le 5 \times 10^4)$。然后，他购买一块长木板，长度刚好可以锯成 $N$ 块木板（即长度为 $L_i$ 的长度之和）。

每次切断模板的开销是这段木板的长度，比如长度为 $21$ 的木板要切成长度为 $5, 8, 8$ 的三块木板，可先先将长度为 $21$ 的木板切成长度为 $13$ 和 $8$ 的木板时，开销为 $21$，再将长度为 $13$ 的木板切成长度为 $5$ 和 $8$ 的木板时，开销是 $13$，于是总开销是 $31 + 13 = 34$。

请求出将木板切成 $L_1, L_2, ..., L_N$ 的长度的最小开销是多少 

# 输入格式

输入包含 $2$ 行

第 $1$ 行包含一个整数 $N$，代表最后要分割成的木板数

第 $2$ 行包含 $N$ 个整数，代表分割后每块木板的长度 $L_i$

# 输出格式

输出一个整数，为分割木板的最小开销

```input1
3
8 5 8
```

```output1
34
```

# 提示
**【样例解释 1】**
* 可先先将长度为 $21$ 的木板切成长度为 $13$ 和 $8$ 的木板时，开销为 $21$
* 再将长度为 $13$ 的木板切成长度为 $5$ 和 $8$ 的木板时，开销是 $13$
* 于是总开销是 $31 + 13 = 34$

<details>
<summary>请思考后再点击查看提示</summary>

* 分割不好考虑，不妨倒过来考虑合并
* 每次都找最短的 $2$ 个木板合并
* 先将长度为 $5$ 和 $8$ 的木板合并，得到长度为 $13$ 的木板，话费 $13$
* 再将长度为 $8$ 和 长度为 $13$ 的木板合并，得到长度为 $21$ 的木板，花费 $21$
* 总花费 $13 + 21 = 34$
* 每次找最小，可以用如下数据结构实现
```c++
priority_queue<int> q;    // 优先队列, 默认每次返回最大
q.push(-8);               // 每次插入负数, 可实现每次返回最小
q.push(-5);
q.push(-8);
cout << q.top() << '\n';  // 返回 -5
```
* 注意：本题的答案需要使用 long long

</details>

# 数据规模与限制
* $1 \le N \le 2 \times 10^4, 1 \le L_i \le 5 \times 10^4$
* 1s, 1024KiB for each test case.

# 来源
* [USACO 2006 November Gold](http://poj.org/problem?id=3253)