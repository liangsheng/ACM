# 题目描述
有 $N$ 组物品和一个容量是 $V$ 的背包。

**<font color="#FF0000">每组物品有若干个，同一组内的物品最多只能选一个</font>**。  
每件物品的体积是 $v_{ij}$，价值是 $w_{ij}$，其中 $i$ 是组号，$j$ 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

# 输入格式

第一行有两个整数 $N，V$，用空格隔开，分别表示物品组数和背包容量。

接下来有 $N$ 组数据：

*   每组数据第一行有一个整数 $S_i$，表示第 $i$ 个物品组的物品数量；
*   每组数据接下来有 $S_i$ 行，每行有两个整数 $v_{ij}, w_{ij}$，用空格隔开，分别表示第 $i$ 个物品组的第 $j$ 个物品的体积和价值；

# 输出格式

输出一个整数，表示最大价值。

```input1
3 5
2
1 2
2 4
1
3 4
1
4 5
```

```output1
8
```

# 提示
**【样例解释 1】**
* 可以选择第 1 组里的第 2 个物品 和 第 2 组里的第 1 个物品
* 总体积为：2 + 3 = 5 <= 5
* 总价值为：4 + 4 = 8

<details>
<summary><font color="#FF0000">请思考后再点击查看提示</font></summary>

* 状态设计，状态转移同 01背包
* **<font color="#FF0000">从大到小枚举体积 $j$ 时，依次用组里每个物品去更新 $dp[j]$ </font>**
```c++
vector<int> dp(V + 1, 0);
for (int i = 1; i <= n; i++) {
    cin >> s;
    vector<int> v(s), w(s);
    for (int j = 0; j < s; j++) cin >> v[j] >> w[j];
    // 从大到小枚举体积 j 时，依次用组里每个物品去更新 dp[j]
    for (int j = V; j >= 0; j--) {
        for (int k = 0; k < s; k++) {
            if (j >= v[k]) dp[j] = max(dp[j], dp[j - [k]] + w[k]);
        }
    }
}
```

</details>

# 数据规模与限制
* $0 \lt N, V \le 100$  
* $0 \lt S_i \le 100$  
* $0 \lt v_{ij}, w_{ij} \le 100$

# 来源
* [acwing: 9.分组背包问题](https://www.acwing.com/problem/content/9/)